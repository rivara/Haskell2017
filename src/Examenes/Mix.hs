
module Examenes.Mix where
--Hoja de Ejercicios 5
--Programación Declarativa
--1
--Hoja de Ejercicios 5 – Ejercicios de exámenes
--Listado de ejercicios de diferentes exámenes de cursos anteriores.
--Ejercicios:
--1) Dada una matriz cuadrada expresada en Haskell como [[Int]], se pretende desarrollar un código Haskell que compruebe si todas las filas y todas las columnas de la matriz suman lo mismo. Para ello, se parte de un código ya implementado que contiene algunos errores. Una posible aplicación de la función sería como sigue:
--Examen> matriz [[4,9,2],[3,5,7],[8,1,6]] True
--Suponiendo que la matriz de entrada es correcta (igual número de filas que de columnas), localiza los errores y explica cómo podrían subsanarse.
--1: matriz::[[Int]]-> Bool
--2: matriz [] = True
--3: matriz (x:xs) = horizontales (suma(x),x:xs) && verticales(suma(x),x:xs)
--4: horizontales :: (Int, [[Int]]) -> Bool
--5: horizontales (_,[]) = True
--6: horizontales (valor, x:xs) =
--7: if suma (x) == valor then horizontales(valor,xs)
--8: else False
--9: verticales :: (Int, [[Int]]) -> Bool
--10: verticales (_,[]) = True
--11: verticales (valor, m) =
--12: if suma (dameColumna(m)) then verticales(valor,quitaColumna(m))
--13: else False
--14: dameColumna :: [[Int]] -> [Int]
--15: dameColumna [] = []
--16: dameColumna ((y:ys):xs) = y:dameColumna(xs)
--17: quitaColumna :: [[Int]] -> [[Int]]
--18: quitaColumna [] = []
--19: quitaColumna (x:xs) = head(x):quitaColumna(xs)
--20: suma :: [Int] -> Int
--21: suma (x:xs) = x + suma(xs)
--2) Se pide implementar un programa en Haskell que sea capaz de obtener el número de errores de una tabla de multiplicar, junto con los elementos de la tabla con los errores. Por ejemplo, si recibe la siguiente tabla del 1 el resultado debería de ser algo como: "Hay 0 errores, que son: ".
--Hoja de Ejercicios 5
--Programación Declarativa-
--2
--1 × 0 = 0
--1 × 1 = 1
--1 × 2 = 2
--1 × 3 = 3
--1 × 4 = 4
--1 × 5 = 5
--1 × 6 = 6
--1 × 7 = 7
--1 × 8 = 8
--1 × 9 = 9
--1 × 10 = 10
--Sin embargo si recibe la siguiente tabla del 3 el resultado debería de ser algo como:
--Hay 4 errores, que son: 4x1=3, 3x3=10, 3x6=20, 3x3=24".
--3 × 0 = 0 4 × 1 = 3
--3 × 2 = 6 3 × 3 = 10
--3 × 4 = 12
--3 × 5 = 15 3 × 6 = 20
--3 × 7 = 21 3 × 3 = 24
--3 × 9 = 27
--3 × 10 = 30
--Se valorará positivamente la claridad y extensibilidad del código, así como la definición de tipos de datos adecuados para la resolución del problema.
--3) Dada una matriz cuadrada expresada en Haskell como [[Int]], se pretende desarrollar un código Haskell que compruebe si todas las filas y todas las columnas de la matriz suman lo mismo. Para ello, se parte de un código ya implementado que contiene algunos errores. Una posible llamada a la función sería como sigue:

--4) Se pide implementar un programa en Haskell que sea capaz de obtener las estadísticas de los resultados de un equipo de fútbol en una temporada determinada. Debe ser lo suficientemente general como para que se pueda aplicar a diferentes temporadas y en diferentes ligas.
--Una temporada se compone de diferentes jornadas, cada jornada se compone de una serie de encuentros y cada encuentro contiene información de los dos equipos que y del resultado final del partido, como se puede ver en la Figura 1.
--Figura 1. Ejemplo de las dos primeras jornadas de la liga de la temporada 2010/2011
--Hoja de Ejercicios 5
--Programación Declarativa
--4
--Un ejemplo podría ser una liga con 4 equipos (R. Madrid, Valencia, Betis y Atlético de Madrid), donde los resultados de las 3 únicas jornadas de la temporada pasada fueron:
--Jornada 1:
--R. Madrid – Betis (2-1)
--Atlético de Madrid – Valencia (6,1)
--Jornada 2:
--Valencia – R. Madrid (1,5)
--Betis – Atlético de Madrid (3,3)
--Jornada 3:
--Betis –Valencia (0,0)
--R. Madrid – Atlético de Madrid (3,3)
-- Si se quieren conocer las estadísticas del R. Madrid para dicha temporada un ejemplo de aplicación de función podría ser el siguiente:--
-- > estadisticas(madrid,temporada2010_2011)
--(Ganados: 2, Empatados: 1, Perdidos: 0)
--Se valorará positivamente la claridad y extensibilidad del código, así como la definición de tipos de datos adecuados para la resolución del problema.
--5) Una característica interesante de los árboles binarios es que partiendo de un recorrido en orden y de un recorrido en preorden se puede reconstruir el árbol de manera unívoca. Crear una función, recEn_PreOrden, que dadas dos listas, una del recorrido en orden de un árbol binario y otra del recorrido en preorden, devuelva el árbol correspondiente. El tipo de dato a utilizar será:
--data Arbol = AV | Nodo Arbol Int Arbol deriving Show
--Sugerencia para la resolución del ejercicio:
--Dados los recorridos en orden y preorden del árbol ejemplo, lo reconstruiríamos dando los siguientes pasos:
--Paso 1 Encontrar la raíz y subdividir los recorridos. La raíz siempre es el primer elemento del preorden. Al localizar dicho elemento en el recorrido en orden, se obtienen los recorridos para los dos subárboles que se le deben asociar como izquierdo y derecho.
-- Preorden: 2
--1
--4
--3
--5
--2
--En orden:
--1
--
--3
--4
--5

--Paso 2 Conociendo el número de elementos de cada uno de los subárboles (1 el izquierdo y 3 el derecho), es posible calcular el recorrido en preorden de cada uno de ellos.
--Preorden: 2 1
--4
--3
--5
--Paso 3 Repetir el paso 1 con cada uno de los subárboles encontrados.
--Preorden: 2 1
--4
--3
--5
--2
--3
--5
--Paso 4 Repetir el paso 2 con cada uno de los subárboles encontrados.
--Preorden: 2 1
--4
--3
--5
--6) La criba de Eratóstenes es un algoritmo que permite hallar todos los números primos menores que un número natural dado n. Se parte de una lista con todos los números naturales comprendidos entre 2 y n, y se van eliminando los números que no son primos de la siguiente manera: Comenzando por el 2, se eliminan todos sus múltiplos; comenzando de nuevo, cuando se encuentra un número entero que no ha sido eliminado, ese número es declarado primo, y se procede a eliminar todos sus múltiplos, así sucesivamente.
--Ejemplo, números primos menores de 16: Ejemplo, números primos menores de 16: Ejemplo, números primos menores de 16: Ejemplo, números primos menores de 16:Ejemplo, números primos menores de 16:Ejemplo, números primos menores de 16:Ejemplo, números primos menores de 16:Ejemplo, números primos menores de 16: Ejemplo, números primos menores de 16: Ejemplo, números primos menores de 16:Ejemplo, números primos menores de 16: Ejemplo, números primos menores de 16: Ejemplo, números primos menores de 16: Ejemplo, números primos menores de 16:Ejemplo, números primos menores de 16:Ejemplo, números primos menores de 16:Ejemplo, números primos menores de 16:Ejemplo, números primos menores de 16:Ejemplo, números primos menores de 16:Ejemplo, números primos menores de 16:Ejemplo, números primos menores de 16:Ejemplo, números primos menores de 16: Ejemplo, números primos menores de 16:
--lista de partida lista de partida lista de partida lista de partida lista de partida lista de partida lista de partida lista de partida lista de partida lista de partida lista de partida -> [2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16]> [2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16]> [2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16] > [2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16]> [2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16]> [2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16] > [2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16]> [2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16] > [2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16] > [2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16] > [2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16] > [2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16]> [2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16] > [2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16] > [2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16] > [2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16] > [2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16] > [2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16] > [2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16] > [2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16] > [2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16] > [2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16] > [2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16]> [2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16] > [2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16]> [2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16] > [2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16] > [2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16]
--se eliminan los divisibles ent se eliminan los divisibles ent se eliminan los divisibles ent se eliminan los divisibles ent se eliminan los divisibles entse eliminan los divisibles entse eliminan los divisibles ent se eliminan los divisibles entse eliminan los divisibles ent se eliminan los divisibles entse eliminan los divisibles entse eliminan los divisibles ent se eliminan los divisibles ent se eliminan los divisibles ent se eliminan los divisibles entre 2 re 2 re 2 -> [2, 3, 5, 7, 9, 11, 13, 15]> [2, 3, 5, 7, 9, 11, 13, 15]> [2, 3, 5, 7, 9, 11, 13, 15]> [2, 3, 5, 7, 9, 11, 13, 15] > [2, 3, 5, 7, 9, 11, 13, 15] > [2, 3, 5, 7, 9, 11, 13, 15]> [2, 3, 5, 7, 9, 11, 13, 15] > [2, 3, 5, 7, 9, 11, 13, 15] > [2, 3, 5, 7, 9, 11, 13, 15] > [2, 3, 5, 7, 9, 11, 13, 15]> [2, 3, 5, 7, 9, 11, 13, 15] > [2, 3, 5, 7, 9, 11, 13, 15] > [2, 3, 5, 7, 9, 11, 13, 15]> [2, 3, 5, 7, 9, 11, 13, 15]> [2, 3, 5, 7, 9, 11, 13, 15] > [2, 3, 5, 7, 9, 11, 13, 15]
--se eliminan los divisibles entre 3 se eliminan los divisibles entre 3 se eliminan los divisibles entre 3 se eliminan los divisibles entre 3 se eliminan los divisibles entre 3 se eliminan los divisibles entre 3 se eliminan los divisibles entre 3 se eliminan los divisibles entre 3 se eliminan los divisibles entre 3 se eliminan los divisibles entre 3 se eliminan los divisibles entre 3 se eliminan los divisibles entre 3 se eliminan los divisibles entre 3 se eliminan los divisibles entre 3 se eliminan los divisibles entre 3 se eliminan los divisibles entre 3 se eliminan los divisibles entre 3 se eliminan los divisibles entre 3 -> [2, 3, 5, 7, 11, 13]> [2, 3, 5, 7, 11, 13]> [2, 3, 5, 7, 11, 13]> [2, 3, 5, 7, 11, 13] > [2, 3, 5, 7, 11, 13] > [2, 3, 5, 7, 11, 13]> [2, 3, 5, 7, 11, 13] > [2, 3, 5, 7, 11, 13] > [2, 3, 5, 7, 11, 13] > [2, 3, 5, 7, 11, 13] > [2, 3, 5, 7, 11, 13] > [2, 3, 5, 7, 11, 13]

--Se solicita la implementación Se solicita la implementaciónSe solicita la implementación Se solicita la implementación Se solicita la implementación Se solicita la implementación Se solicita la implementaciónSe solicita la implementación Se solicita la implementaciónSe solicita la implementaciónSe solicita la implementaciónSe solicita la implementación de una función erastóde una función erastó de una función erastóde una función erastóde una función erastó de una función erastóde una función erastóde una función erastóde una función erastóde una función erastóde una función erastó de una función erastóde una función erastó de una función erastóde una función erastóde una función erastóde una función erastótenes, que recibe un número entero > 1 y tenes, que recibe un número entero > 1 y tenes, que recibe un número entero > 1 y tenes, que recibe un número entero > 1 y tenes, que recibe un número entero > 1 y tenes, que recibe un número entero > 1 y tenes, que recibe un número entero > 1 y tenes, que recibe un número entero > 1 y tenes, que recibe un número entero > 1 y tenes, que recibe un número entero > 1 y tenes, que recibe un número entero > 1 y tenes, que recibe un número entero > 1 y tenes, que recibe un número entero > 1 y tenes, que recibe un número entero > 1 y tenes, que recibe un número entero > 1 y tenes, que recibe un número entero > 1 y tenes, que recibe un número entero > 1 y tenes, que recibe un número entero > 1 y tenes, que recibe un número entero > 1 y tenes, que recibe un número entero > 1 y tenes, que recibe un número entero > 1 y tenes, que recibe un número entero > 1 y tenes, que recibe un número entero > 1 y tenes, que recibe un número entero > 1 y tenes, que recibe un número entero > 1 y tenes, que recibe un número entero > 1 y tenes, que recibe un número entero > 1 y devuelve la lista de números primos que hay entre 2 y él.devuelve la lista de números primos que hay entre 2 y él. devuelve la lista de números primos que hay entre 2 y él. devuelve la lista de números primos que hay entre 2 y él. devuelve la lista de números primos que hay entre 2 y él. devuelve la lista de números primos que hay entre 2 y él.devuelve la lista de números primos que hay entre 2 y él. devuelve la lista de números primos que hay entre 2 y él.devuelve la lista de números primos que hay entre 2 y él. devuelve la lista de números primos que hay entre 2 y él.devuelve la lista de números primos que hay entre 2 y él. devuelve la lista de números primos que hay entre 2 y él.devuelve la lista de números primos que hay entre 2 y él.devuelve la lista de números primos que hay entre 2 y él.devuelve la lista de números primos que hay entre 2 y él. devuelve la lista de números primos que hay entre 2 y él. devuelve la lista de números primos que hay entre 2 y él.devuelve la lista de números primos que hay entre 2 y él. devuelve la lista de números primos que hay entre 2 y él. devuelve la lista de números primos que hay entre 2 y él.devuelve la lista de números primos que hay entre 2 y él.devuelve la lista de números primos que hay entre 2 y él. devuelve la lista de números primos que hay entre 2 y él.devuelve la lista de números primos que hay entre 2 y él.devuelve la lista de números primos que hay entre 2 y él. devuelve la lista de números primos que hay entre 2 y él.devuelve la lista de números primos que hay entre 2 y él.devuelve la lista de números primos que hay entre 2 y él.devuelve la lista de números primos que hay entre 2 y él. devuelve la lista de números primos que hay entre 2 y él. devuelve la lista de números primos que hay entre 2 y él. devuelve la lista de números primos que hay entre 2 y él.
-- > er astotenes 16
--[2, 3, 5, 7, 11, 13]
--7) Dada la siguiente definición de tipos:Dada la siguiente definición de tipos:Dada la siguiente definición de tipos:Dada la siguiente definición de tipos: Dada la siguiente definición de tipos: Dada la siguiente definición de tipos:Dada la siguiente definición de tipos: Dada la siguiente definición de tipos: Dada la siguiente definición de tipos:Dada la siguiente definición de tipos:Dada la siguiente definición de tipos: Dada la siguiente definición de tipos:Dada la siguiente definición de tipos:Dada la siguiente definición de tipos:Dada la siguiente definición de tipos:Dada la siguiente definición de tipos:Dada la siguiente definición de tipos: Dada la siguiente definición de tipos: Dada la siguiente definición de tipos:Dada la siguiente definición de tipos:Dada la siguiente definición de tipos: Dada la siguiente definición de tipos:Dada la siguiente definición de tipos: Dada la siguiente definición de tipos:
--data Arbol a = AVacio | Rama (a)
--Implemente la operación Implemente la operación Implemente la operación Implemente la operación Implemente la operación Implemente la operación Implemente la operación Implemente la operación Implemente la operación Implemente la operación Implemente la operación Implemente la operación Implemente la operación recorridoPreOrden , que recibe un , que recibe un , que recibe un , que recibe un , que recibe un , que recibe un , que recibe un , que recibe un , que recibe un , que recibe un , que recibe un Arbol a Arbol a Arbol a Arbol a, y devuelve en una , y devuelve en una , y devuelve en una , y devuelve en una , y devuelve en una , y devuelve en una , y devuelve en una , y devuelve en una , y devuelve en una , y devuelve en una , y devuelve en una , y devuelve en una , y devuelve en una , y devuelve en una lista los valores de lista los valores de lista los valores de lista los valores de lista los valores de lista los valores de lista los valores de lista los valores de lista los valores de lista los valores de lista los valores de lista los valores de a almacenados en el almacenados en el almacenados en el almacenados en el almacenados en el almacenados en el almacenados en el almacenados en el almacenados en el almacenados en el Arbol a siguiendo este recorrido. siguiendo este recorrido. siguiendo este recorrido.siguiendo este recorrido. siguiendo este recorrido.siguiendo este recorrido.siguiendo este recorrido.siguiendo este recorrido. siguiendo este recorrido.siguiendo este recorrido. siguiendo este recorrido. siguiendo este recorrido. siguiendo este recorrido.
--En orden: 1
-- 4
--Hoja de Ejercicios 5
--Programación Declarativa
--6
--8) Dada la siguiente definición de tipos:Dada la siguiente definición de tipos:Dada la siguiente definición de tipos:Dada la siguiente definición de tipos: Dada la siguiente definición de tipos: Dada la siguiente definición de tipos:Dada la siguiente definición de tipos: Dada la siguiente definición de tipos: Dada la siguiente definición de tipos:Dada la siguiente definición de tipos:Dada la siguiente definición de tipos: Dada la siguiente definición de tipos:Dada la siguiente definición de tipos:Dada la siguiente definición de tipos:Dada la siguiente definición de tipos:Dada la siguiente definición de tipos:Dada la siguiente definición de tipos: Dada la siguiente definición de tipos: Dada la siguiente definición de tipos:Dada la siguiente definición de tipos:Dada la siguiente definición de tipos: Dada la siguiente definición de tipos:Dada la siguiente definición de tipos: Dada la siguiente definición de tipos:
--data Arbol a = AVacio | Rama (a) deriving Show)
--Implemente la mplemente la mplemente la mplemente la mplemente la mplemente la mplemente la funciónfunciónfunciónfunciónfunción hermanos , que recibe un , que recibe un , que recibe un , que recibe un , que recibe un , que recibe un , que recibe un , que recibe un , que recibe un , que recibe un , que recibe un , que recibe un Arbol a Arbol a Arbol a Arbol a, y dos nodos y dos nodosy dos nodos y dos nodosy dos nodosy dos nodosy dos nodosy dos nodos y devuelva devuelva devuelva devuelva devuelva True si si si esos dos nodos tienenesos dos nodos tienen esos dos nodos tienenesos dos nodos tienen esos dos nodos tienenesos dos nodos tienen esos dos nodos tienen esos dos nodos tienenesos dos nodos tienenesos dos nodos tienenesos dos nodos tienen esos dos nodos tienenesos dos nodos tienen el mismo nodo padre y el mismo nodo padre y el mismo nodo padre y el mismo nodo padre y el mismo nodo padre y el mismo nodo padre y el mismo nodo padre y el mismo nodo padre y el mismo nodo padre y el mismo nodo padre y el mismo nodo padre y el mismo nodo padre y el mismo nodo padre y el mismo nodo padre y False FalseFalse en caso contrario. en caso contrario.en caso contrario.en caso contrario.en caso contrario. en caso contrario.en caso contrario.en caso contrario. en caso contrario.en caso contrario. en caso contrario.
--9) A partir de la información sobre los torneos de tenis celebrados en una temporada, donde de cada torneo se conoce el nombre del mismo, el nombre de los dos jugadores finalistas, y el resultado del partido, tal y como se puede ver en el ejemplo de la Tabla 1.
--Torneo
--Finalistas
--Resultado
--Open de Australia
--Novak Djokovic
--Andy Murray
--6 7 6 6
--7 6 3 2
--Indian Wells
--Juan Martín del Potro
--Rafael Nadal
--6 3 4
--4 6 6
--Mutua Madrid Open
--Rafael Nadal Stanislas Wawrinka
--6 6
--2 4
--Wimbledon
--Novak Djokovic
--Andy Murray
--6 7 6-
--4 5 4
--Tabla 1. Información de diferentes torneos de la temporada de tenis 2013
--Se pide implementar el código Haskell necesario para poder aplicar una función que dada la información de una temporada presente un listado (ordenado alfabéticamente según el nombre del torneo) con el nombre de los torneos, el jugador ganador y el número de sets jugados en la final.
--Por ejemplo, con los datos contenidos en la Tabla 1, un ejemplo de aplicación de la función podría ser1:
-- > mostrarListadoOrdenadoTorneos temporada2013
--"Indian Wells, Ganador: Rafael Nadal, en 3 sets.
--Mutua Madrid Open, Ganador: Rafael Nadal, en 2 sets.
--Open de Australia, Ganador: Novak Djokovic, en 4 sets.
--Wimbledon, Ganador: Andy Murray, en 3 sets.\n"
--Como se puede ver en el ejemplo, los datos de la temporada tenística 2013 se han declarado en temporada2013, sin embargo la aplicación de la función mostrarListadoOrdenadoTorneos puede variar dependiendo del diseño y la implementación que haga cada uno para resolver lo que se pide.
--1 Aunque el listado resultado de aplicar la función mostrarListadoOrdenadoTorneos se ha presentado en diferentes líneas, no es necesario que aparezca así para resolver el ejercicio.
--Hoja de Ejercicios 5
--Programación Declarativa
--7
--El listado resultante los nombres de los torneos, al aplicar la función, se encuentra ordenados alfabéticamente por nombre de torneo, tal y como se pedía. Además, para cada torneo se indica quién es el jugador ganador y cuántos sets se jugaron en la final.
--Para calcular el jugador ganador es necesario analizar el resultado del partido set por set. Por ejemplo, en el Open de Australia se jugaron 4 sets:
--Set 1 Set 2 Set 3 Set 4 Novak Djokovic 6 7 6 6 Andy Murray 7 6 3 2
--Como se puede ver en la tabla, Murray ganó el primer set, porque obtuvo un número de puntos (7) superior a los obtenidos por Djokovic (6) en el mismo set, mientras que en los tres sets restantes el ganador fue este último, ya que su puntuación era superior a la obtenida por Murray en cada uno de ellos. Por tanto, Djokovic ganó tres de los cuatro sets jugados, siendo así el ganador del partido.
--A continuación se proporciona una función de ordenación mediante el método del quicksort, por si resulta de utilidad.
--qs::Ord a=>[a]->[a]
--qs [] = []
--qs (p:xs) = qs [x|x<-xs,x<p] ++ [p] ++ qs [x|x<-xs,x>=p]
--Se valorará positivamente la claridad y extensibilidad del código, así como la definición de tipos de datos adecuados para la resolución del problema.
--10) Dada la siguiente función:Dada la siguiente función:Dada la siguiente función:Dada la siguiente función: Dada la siguiente función:Dada la siguiente función: Dada la siguiente función: Dada la siguiente función:Dada la siguiente función: Dada la siguiente función:Dada la siguiente función: Dada la siguiente función:Dada la siguiente función:Dada la siguiente función:Dada la siguiente función:Dada la siguiente función: Dada la siguiente función:
--insert :: (Ord a) => Tree a -> a -> Tree a
--insert Empty x = L eaf x
--insert (Node x l r) y = case compare of
--GT -> Node x l (insert r y)
--_ -> N ode x (insert l y) r
--Y el siguiente tipo de datos: Y el siguiente tipo de datos: Y el siguiente tipo de datos: Y el siguiente tipo de datos:Y el siguiente tipo de datos: Y el siguiente tipo de datos:Y el siguiente tipo de datos:Y el siguiente tipo de datos:Y el siguiente tipo de datos:Y el siguiente tipo de datos:Y el siguiente tipo de datos:Y el siguiente tipo de datos: Y el siguiente tipo de datos:Y el siguiente tipo de datos: Y el siguiente tipo de datos:Y el siguiente tipo de datos:Y el siguiente tipo de datos:Y el siguiente tipo de datos:
--data Student = {fullname:: String,
--age:: Integer, qualifications:: [Integer]}
--Hoja de Ejercicios 5
--Programación Declarativa
--8
--Se pide definir las instancias que permitan insertar valores de tipo Student en un árbol mediante el método insert. Nótese que aunque la definición del tipo Student utiliza la notación registro, sus valores pueden referenciarse utilizando los patrones habituales:
--Student n a qs
--11) Un grafo es una estructura de datos que consiste en un conjunto de nodos (o vértices) y un conjunto de arcos (o aristas) que establecen relaciones entre los nodos. Se puede hablar de grafos dirigidos o no dirigidos, donde ambos se pueden representar mediante listas de adyacencia o matrices de adyacencia. Un ejemplo se muestra en la siguiente figura:
--Se pide lo siguiente:
--a) Definición de los tipos de datos necesarios en Haskell para representar un Grafo No Dirigido mediante Listas de Adyacencia. Además, los nodos del grafo pueden ser de cualquier tipo.
--b) Con los tipos de datos definidos, implementar la creación del siguiente grafo:
--Hoja de Ejercicios 5
--Programación Declarativa
--9
--c) Implementar una función que dados dos nodos y un grafo indique si los nodos son adyacentes.
--d) Implementar una función que dados dos grafos indique si son iguales, es decir, que tengan los mismos nodos y las mismas aristas.
--12) En un restaurante se desea gestionar las mesas libres y ocupadas de forma que se puedan asignar mesas rápidamente según llegan los comensales. De cada mesa se necesita conocer el número de mesa y su capacidad. Se pide implementar un tipo de datos Ocupacion, donde se puedan saber las mesas libres y las mesas ocupadas. La representación por pantalla del tipo ocupación debe ser la siguiente:
--Libres:
--[Mesa 1 -> Capacidad:10]
--Ocupadas:
--[Mesa 2 -> Capacidad:20]
--Se pide además implementar las siguientes funciones:
-- insertarMesaLibre: esta función, dada una ocupación y una mesa, inserta la mesa en la lista de mesas libres de forma ordenada, con las mesas con menor capacidad primero.
-- ocuparMesa: dada una ocupación y un número de comensales, esta función devuelve una nueva ocupación, donde a los comensales se les ha asignado la mesa libre más pequeña en la que caben todos, y esta mesa ha sido añadida a la lista de mesas ocupadas y eliminada de la lista de mesas libres.
--13) Dado el siguiente código en Haskell, donde se han definido nuevos tipos de datos para representar artículos de noticias. Cada artículo está representado por un título, una fecha de publicación y un resumen.
--type Title = String
--type Abstract = String
--type Day = Int
--type Month = Int
--type Year = Int
--data Date = D Day Month Year deriving Show
--data Article = Art Title Date Abstract deriving Show
-- Funciones para comparar fechas
--equal :: Date -> Date -> Bool
--equal (D d1 m1 y1) (D d2 m2 y2) = d1==d2 && m1==m2 && y1==y2
--lessThan :: Date -> Date -> Bool
--lessThan (D d1 m1 y1) (D d2 m2 y2) = y1 < y2 || (y1==y2) && (m1 < m2)
-- || (y1==y2) && (m1==m2) && (d1<d2)
--Hoja de Ejercicios 5
--Programación Declarativa
--10
--greaterThan :: Date -> Date -> Bool
--greaterThan date1 date2 = not (equal date1 date2) && not (lessThan date1 date2)
-- Funciones de ordenación de listas
--mitades :: [a] -> ([a],[a])
--mitades xs = splitAt (length xs `div` 2) xs
--mezcla :: Ord a => [a] -> [a] -> [a]
--mezcla [] ys = ys
--mezcla xs [] = xs
--mezcla (x:xs) (y:ys) | x <= y = x : mezcla xs (y:ys)
-- | otherwise = y : mezcla (x:xs) ys
--ordMezcla :: Ord a => [a] -> [a]
--ordMezcla [] = []
--ordMezcla [x] = [x]
--ordMezcla xs = mezcla (ordMezcla ys) (ordMezcla zs)
--where (ys,zs) = mitades xs
-- Declaración de datos concretos
--date1 :: Date
--date1 = D 16 06 2015
--date2 :: Date
--date2 = D 10 05 2015
--date3 :: Date
--date3 = D 09 01 2014
--date4 :: Date
--date4 = D 10 05 2015
--article1 = Art "Pope Francis Calls for Climate Action in Draft of Encyclical"
--date1 "Pope Francis offers a broad vision of..."
--article2 = Art "Discontent in Eastern Ukraine Leads to Rare Public Protest"
--date2 "Residents of two frequently shelled..."
--article3 = Art "Hong Kong Police Arrest 9 Ahead of Contentious Vote"
--date3 "The Hong Kong police said on Monday that..."
--article4 = Art "DnA Deciphers Roots of Modern Europeans" date4
--"For centuries, archaeologists have..."
--articlesList = [article1,article2,article3,article4]
--Se pide añadir el código necesario para que la lista de artículos de noticias pueda ser ordenada utilizando la función ordMezcla como sigue:
--Module> ordMezcla articlesList